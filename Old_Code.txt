import os
import pickle
import random
import time

import numpy
from matplotlib import pyplot
from scipy.interpolate import RegularGridInterpolator
from scipy.interpolate.interpnd import LinearNDInterpolator
from scipy.spatial.distance import cdist

import Acoustics
import Geometry
import Misc
from Acoustics import default_atmosphere, make_erb_cfs


class TransferFunction:
    def __init__(self, source, freq1, freq2, total=True):
        self.left = None
        self.right = None
        self.nose = None
        self.data = None
        self.frequency_range = None
        self.left_function = None
        self.right_function = None
        self.left_db = None
        self.right_db = None
        self.points = None
        self.read_pickle(source)
        self.prepare_hrtf(freq1, freq2)
        self.make_hrtf(total)

    def read_pickle(self, source):
        local = os.path.abspath(__file__)
        dir = os.path.dirname(local)
        name = 'hrtfs/' + source + '.hrtf'
        name = os.path.join(dir, name)
        stream = open(name, 'rb')
        self.data = pickle.load(stream)
        stream.close()

    def prepare_hrtf(self, freq1, freq2):
        freq = self.data['freq']
        left = self.data['left']
        right = self.data['right']
        nose = self.data['nose']

        value1, index1 = Misc.closest(freq, freq1)
        value2, index2 = Misc.closest(freq, freq2)
        index2 += 1

        left = left[:, :, index1:index2]
        right = right[:, :, index1:index2]
        nose = nose[:, :, index1:index2]

        self.frequency_range = freq[index1:index2]
        self.left = numpy.mean(left, 2)
        self.right = numpy.mean(right, 2)
        self.nose = numpy.mean(nose, 2)

    def make_hrtf(self, total=True):
        left = self.left
        right = self.right
        if total:
            left = self.left * self.nose
            right = self.right * self.nose

        az_grid, el_grid = Misc.angle_arrays(grid=True)
        az = az_grid.flatten()
        el = el_grid.flatten()

        left_db = 20 * numpy.log10(left / numpy.max(left))
        right_db = 20 * numpy.log10(right / numpy.max(right))

        left_db = left_db.flatten()
        right_db = right_db.flatten()
        points = numpy.column_stack((az, el))
        self.left_function = LinearNDInterpolator(points, left_db)
        self.right_function = LinearNDInterpolator(points, right_db)
        self.left_db = left_db
        self.right_db = right_db
        self.points = (az,el)

    def get_directivity(self, az_i, el_i):
        shape = az_i.shape
        az_i = az_i.flatten()
        el_i = el_i.flatten()
        az_i = numpy.squeeze(az_i)
        el_i = numpy.squeeze(el_i)
        points = numpy.column_stack((az_i, el_i))
        left_data = self.left_function(points)
        right_data = self.right_function(points)
        left_data = numpy.reshape(left_data, shape)
        right_data = numpy.reshape(right_data, shape)
        return left_data, right_data

    def plot(self,left=True):
        az = self.points[0]
        el = self.points[1]
        db = self.right_db
        if left: db = self.left_db
        min = db.min()
        max = db.max()
        levels = numpy.linspace(min, max, 20)
        Misc.plot_map(az, el, db, levels= levels)
        pyplot.colorbar()
        pyplot.show()


class Locator:
    def __init__(self, freq1=50000, freq2=90000, source='pd01'):
        self.atmosphere = Acoustics.default_atmosphere()
        self.min_freq = freq1
        self.max_freq = freq2
        self.frequency = (freq1 + freq2) / 2
        self.source_name = source

        self.raw_data = None
        self.transfer_function = None
        self.templates = None
        self.center_frequencies = None
        self.az_array = None
        self.el_array = None

        # acoustic settings
        self.sd_noise = 3
        self.reference_distance = 0.1
        self.reflection_parameter = -20  # Parameter C1 in Stilz and Schnitzler but for 10 cm
        self.spreading_parameter = -40  # Parameter C2 in Stilz and Schnitzler

        self.read_transfer_function()
        self.make_templates()

    @property
    def attenuation_coefficient(self):
        return self.atmosphere.attenuation_coefficient(self.frequency) * -1

    def spreading(self, distance):
        distance = numpy.array(distance, dtype='f')
        return self.spreading_parameter * numpy.log10(distance / self.reference_distance)

    def attenuation(self, distance):
        distance = numpy.array(distance, dtype='f')
        return self.attenuation_coefficient * distance * 2

    def read_transfer_function(self):
        local = os.path.abspath(__file__)
        folder = os.path.dirname(local)
        name = 'hrtfs/' + self.source_name + '.hrtf'
        name = os.path.join(folder, name)
        stream = open(name, 'rb')
        data = pickle.load(stream)
        stream.close()
        self.raw_data = data

    def make_templates(self):
        nose = self.raw_data['nose']
        left = self.raw_data['left']
        freq = self.raw_data['freq']
        az = numpy.arange(-180, 181, 2.5)
        el = numpy.arange(-90, 91, 2.5)

        # make total
        total = nose * left

        # interpolate total
        cf_array = make_erb_cfs(self.min_freq, self.max_freq)
        cf_array = cf_array[cf_array >= numpy.min(freq)]
        cf_array = cf_array[cf_array <= numpy.max(freq)]
        eli = numpy.linspace(-90, 90, 181)
        azi = numpy.linspace(-90, 90, 181)
        extra = numpy.array([180])
        azi = numpy.concatenate((azi, extra))
        az_grid, el_grid, cf_grid = numpy.meshgrid(azi, eli, cf_array)
        interpolator = RegularGridInterpolator((el, az, freq), total)
        total = interpolator((el_grid, az_grid, cf_grid))

        # make templates
        total = total / numpy.max(total)
        log_total_left = 20 * numpy.log10(total)
        log_total_right = numpy.fliplr(log_total_left)

        shape = log_total_left.shape
        template_rows = shape[0] * shape[1]
        template_cols = shape[2]

        left = numpy.reshape(log_total_left, (template_rows, template_cols))
        right = numpy.reshape(log_total_right, (template_rows, template_cols))
        azs, els = numpy.meshgrid(azi, eli)

        self.templates = numpy.concatenate((left, right), axis=1)
        self.center_frequencies = cf_array
        self.az_array = numpy.reshape(azs, (-1, 1))
        self.el_array = numpy.reshape(els, (-1, 1))
        self.az_grid = azs
        self.el_grid = els
        self.transfer_function = {'left': log_total_left, 'right': log_total_right, 'az': az_grid, 'el': el_grid}

    def get_template_sph(self, real_az, real_el, left_only=False):
        template_index = numpy.argmin((self.az_array - real_az) ** 2 + (self.el_array - real_el) ** 2)
        template = self.templates[template_index, :]
        template = numpy.reshape(template, (1, -1))
        length = int(template.shape[1] / 2)
        if left_only: template = template[:, 0:length]
        return template

    def get_template_cart(self, real_x, real_y, real_z, left_only=False):
        real_az, real_el, _ = Geometry.cart2sph(real_x, real_y, real_z)
        return self.get_template_sph(real_az, real_el, left_only)

    def locate(self, real_az, real_el, distance, detection_threshold=20):
        start = time.time()
        out_of_fov = False
        if abs(real_az) > 90: out_of_fov = True
        if abs(real_el) > 90: out_of_fov = True

        spreading = self.spreading(distance)
        attenuation = self.attenuation(distance)

        echo_db = 120 + spreading + attenuation + self.reflection_parameter

        templates = self.templates + echo_db
        measurement = self.get_template_sph(real_az, real_el) + echo_db

        if numpy.max(measurement) < detection_threshold: out_of_fov = True

        # locate if perceivable
        if not out_of_fov:
            shape_templates = templates.shape
            noise = numpy.random.randn(shape_templates[1]) * self.sd_noise
            noisy_measurement = measurement + noise

            templates[templates < detection_threshold] = detection_threshold
            noisy_measurement[noisy_measurement < detection_threshold] = detection_threshold

            dist = cdist(templates, noisy_measurement, 'euclidean')
            index = numpy.argmin(dist)
            perceived_az = self.az_array[index][0]
            perceived_el = self.el_array[index][0]

        # locate if not perceivable
        if out_of_fov:
            perceived_az = random.randint(-90, 90)
            perceived_el = random.randint(-90, 90)

        duration = time.time() - start
        result = {}
        result['echo_db'] = echo_db
        result['spreading'] = spreading
        result['attenuation'] = attenuation
        result['az'] = perceived_az
        result['el'] = perceived_el
        result['duration'] = duration
        result['out_of_fov'] = out_of_fov
        return result














class Sonar:
    def __init__(self, source, frequency, az_rot=0, el_rot=0, dfreq=10000):
        self.atmosphere = default_atmosphere()
        self.emission_db = 120
        self.frequency = frequency
        self.reference_distance = 0.1
        self.reflection_parameter = 0  # Parameter C1 in Stilz and Schnitzler
        self.spreading_parameter = -10  # Parameter C2 in Stilz and Schnitzler
        self.azimuth_rotation = az_rot
        self.elevation_rotation = el_rot
        self.sonar_directivity = TransferFunction(source, frequency - dfreq, frequency + dfreq, az_rot=az_rot, el_rot=el_rot)
        self.restrict_to_front = True

    @property
    def speed(self):
        return self.atmosphere.soundspeed

    @property
    def attenuation_coefficient(self):
        return self.atmosphere.attenuation_coefficient(self.frequency) * -1

    def spreading(self, distance):
        distance = numpy.array(distance)
        return self.spreading_parameter * numpy.log10(distance / self.reference_distance)

    def attenuation(self, distance):
        distance = numpy.array(distance, dtype='f')
        return self.attenuation_coefficient * distance * 2

    def directivity(self, az, el):
        left, right = self.sonar_directivity.get_directivity(az, el)
        return left, right

    def call_sph(self, az, el, distance):
        distance = numpy.asarray(distance)
        left_db, right_db = self.directivity(az, el)
        gain = self.emission_db + self.spreading(distance) + self.attenuation(distance) + self.reflection_parameter
        gain = numpy.squeeze(gain)
        gain_left = gain + left_db
        gain_right = gain + right_db
        delay = self.dist2delay(distance)
        delay = numpy.asarray(delay)
        if self.restrict_to_front:
            gain_left[numpy.abs(az) > 90] = 0
            gain_right[numpy.abs(az) > 90] = 0
        return gain_left, gain_right, gain, delay

    def call_cart(self, x, y, z):
        az, el, distance = Geometry.cart2sph(x, y, z)
        return self.call_sph(az, el, distance)

    def delay2dist(self, delay):
        return delay2dist(delay, self.speed)

    def dist2delay(self, dist):
        return dist2delay(dist, self.speed)
        
        
        
        
        
        
        
        
        
############################################################
